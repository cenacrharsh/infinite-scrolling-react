{"version":3,"sources":["App.js","useBookSearch.js","index.js"],"names":["App","useState","query","setQuery","pageNumber","setPageNumber","loading","setLoading","error","setError","books","setBooks","hasMore","setHasMore","useEffect","cancel","axios","method","url","params","q","page","cancelToken","CancelToken","c","then","res","prevBooks","Set","data","docs","map","b","title","length","catch","e","isCancel","useBookSearch","observer","useRef","lastBookElementRef","useCallback","node","current","disconnect","IntersectionObserver","entries","isIntersecting","prevPageNumber","observe","type","value","onChange","target","book","index","ref","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"oNAwDeA,MApDf,WACE,MAA0BC,mBAAS,IAAnC,mBAAOC,EAAP,KAAcC,EAAd,KACA,EAAoCF,mBAAS,GAA7C,mBAAOG,EAAP,KAAmBC,EAAnB,KAEA,ECJa,SAAuBH,EAAOE,GAC3C,MAA8BH,oBAAS,GAAvC,mBAAOK,EAAP,KAAgBC,EAAhB,KACA,EAA0BN,oBAAS,GAAnC,mBAAOO,EAAP,KAAcC,EAAd,KACA,EAA0BR,mBAAS,IAAnC,mBAAOS,EAAP,KAAcC,EAAd,KACA,EAA8BV,oBAAS,GAAvC,mBAAOW,EAAP,KAAgBC,EAAhB,KAmCA,OAjCAC,qBAAU,WACRH,EAAS,MACR,CAACT,IAEJY,qBAAU,WAIR,IAAIC,EAsBJ,OAzBAR,GAAW,GACXE,GAAS,GAGTO,IAAM,CACJC,OAAQ,MACRC,IAAK,qCACLC,OAAQ,CAAEC,EAAGlB,EAAOmB,KAAMjB,GAC1BkB,YAAa,IAAIN,IAAMO,aAAY,SAACC,GAAD,OAAQT,EAASS,OAEnDC,MAAK,SAACC,GACLf,GAAS,SAACgB,GACR,OAAO,YACF,IAAIC,IAAJ,sBAAYD,GAAZ,YAA0BD,EAAIG,KAAKC,KAAKC,KAAI,SAACC,GAAD,OAAOA,EAAEC,gBAG5DpB,EAAWa,EAAIG,KAAKC,KAAKI,OAAS,GAClC3B,GAAW,MAGZ4B,OAAM,SAACC,GACFpB,IAAMqB,SAASD,IACnB3B,GAAS,MAGN,kBAAMM,OACZ,CAACb,EAAOE,IAEJ,CAAEE,UAASE,QAAOE,QAAOE,WDnCW0B,CAAcpC,EAAOE,GAAxDE,EAAR,EAAQA,QAASM,EAAjB,EAAiBA,QAASF,EAA1B,EAA0BA,MAAOF,EAAjC,EAAiCA,MAE3B+B,EAAWC,mBACXC,EAAqBC,uBACzB,SAACC,GAEKrC,IAEAiC,EAASK,SAASL,EAASK,QAAQC,aAGvCN,EAASK,QAAU,IAAIE,sBAAqB,SAACC,GACvCA,EAAQ,GAAGC,gBAAkBpC,GAE/BP,GAAc,SAAC4C,GAAD,OAAoBA,EAAiB,QAInDN,GAAMJ,EAASK,QAAQM,QAAQP,MAErC,CAACrC,EAASM,IAQZ,OACE,qCACE,uBAAOuC,KAAK,OAAOC,MAAOlD,EAAOmD,SAPrC,SAAsBjB,GACpBjC,EAASiC,EAAEkB,OAAOF,OAClB/C,EAAc,MAMXK,EAAMqB,KAAI,SAACwB,EAAMC,GAChB,OAAI9C,EAAMwB,SAAWsB,EAAQ,EAEzB,qBAAKC,IAAKhB,EAAV,SACGc,GADgCA,GAK9B,8BAAiBA,GAAPA,MAGrB,8BAAMjD,GAAW,eACjB,8BAAME,GAAS,cE/CrBkD,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.445ba0f5.chunk.js","sourcesContent":["import { useState, useRef, useCallback } from \"react\";\r\n\r\nimport useBookSearch from \"./useBookSearch\";\r\n\r\nfunction App() {\r\n  const [query, setQuery] = useState(\"\");\r\n  const [pageNumber, setPageNumber] = useState(1);\r\n\r\n  const { loading, hasMore, books, error } = useBookSearch(query, pageNumber);\r\n\r\n  const observer = useRef();\r\n  const lastBookElementRef = useCallback(\r\n    (node) => {\r\n      // console.log(node);\r\n      if (loading) return;\r\n\r\n      if (observer.current) observer.current.disconnect();\r\n      /* disconnects our observer from previous element so that our new last element would be hooked up correctly */\r\n\r\n      observer.current = new IntersectionObserver((entries) => {\r\n        if (entries[0].isIntersecting && hasMore) {\r\n          // console.log(\"Visible\");\r\n          setPageNumber((prevPageNumber) => prevPageNumber + 1);\r\n        }\r\n      });\r\n\r\n      if (node) observer.current.observe(node);\r\n    },\r\n    [loading, hasMore]\r\n  );\r\n\r\n  function handleSearch(e) {\r\n    setQuery(e.target.value);\r\n    setPageNumber(1);\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <input type=\"text\" value={query} onChange={handleSearch}></input>\r\n      {books.map((book, index) => {\r\n        if (books.length === index + 1) {\r\n          return (\r\n            <div ref={lastBookElementRef} key={book}>\r\n              {book}\r\n            </div>\r\n          );\r\n        } else {\r\n          return <div key={book}>{book}</div>;\r\n        }\r\n      })}\r\n      <div>{loading && \"Loading...\"}</div>\r\n      <div>{error && \"Error\"}</div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import { useEffect, useState } from \"react\";\r\n\r\nimport axios from \"axios\";\r\n\r\nexport default function useBookSearch(query, pageNumber) {\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(false);\r\n  const [books, setBooks] = useState([]);\r\n  const [hasMore, setHasMore] = useState(false);\r\n\r\n  useEffect(() => {\r\n    setBooks([]);\r\n  }, [query]);\r\n\r\n  useEffect(() => {\r\n    setLoading(true);\r\n    setError(false);\r\n\r\n    let cancel;\r\n    axios({\r\n      method: \"GET\",\r\n      url: \"http://openlibrary.org/search.json\",\r\n      params: { q: query, page: pageNumber },\r\n      cancelToken: new axios.CancelToken((c) => (cancel = c)),\r\n    })\r\n      .then((res) => {\r\n        setBooks((prevBooks) => {\r\n          return [\r\n            ...new Set([...prevBooks, ...res.data.docs.map((b) => b.title)]),\r\n          ];\r\n        });\r\n        setHasMore(res.data.docs.length > 0);\r\n        setLoading(false);\r\n        // console.log(res.data);\r\n      })\r\n      .catch((e) => {\r\n        if (axios.isCancel(e)) return;\r\n        setError(true);\r\n      });\r\n\r\n    return () => cancel();\r\n  }, [query, pageNumber]);\r\n\r\n  return { loading, error, books, hasMore };\r\n}\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}